# Generated from /home/loop/Desktop/Ass/Compiler/HW4/three.g4 by ANTLR 4.9.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3&")
        buf.write("\u0129\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\3\2\3\2\7\2/\n\2\f\2\16")
        buf.write("\2\62\13\2\3\2\3\2\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\5")
        buf.write("\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\5\7T\n\7\3\7\3\7\7\7X\n")
        buf.write("\7\f\7\16\7[\13\7\3\7\7\7^\n\7\f\7\16\7a\13\7\3\7\3\7")
        buf.write("\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\7\tp\n\t")
        buf.write("\f\t\16\ts\13\t\5\tu\n\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\13\3\13\3\13\3\13\3\f\3\f\7\f\u0085\n\f\f\f\16\f")
        buf.write("\u0088\13\f\3\f\7\f\u008b\n\f\f\f\16\f\u008e\13\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\5")
        buf.write("\r\u009e\n\r\3\16\3\16\7\16\u00a2\n\16\f\16\16\16\u00a5")
        buf.write("\13\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\3\16\3\16\5\16\u00ca\n\16\3\17\3\17\3\17\3")
        buf.write("\17\3\17\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\22\3\22")
        buf.write("\3\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\5\23\u00fb\n\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3")
        buf.write("\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\7\23\u0113\n\23\f\23\16\23\u0116")
        buf.write("\13\23\5\23\u0118\n\23\3\23\3\23\3\23\7\23\u011d\n\23")
        buf.write("\f\23\16\23\u0120\13\23\3\24\3\24\3\24\3\25\3\25\3\26")
        buf.write("\3\26\3\26\2\3$\27\2\4\6\b\n\f\16\20\22\24\26\30\32\34")
        buf.write("\36 \"$&(*\2\2\2\u0132\2,\3\2\2\2\4\65\3\2\2\2\68\3\2")
        buf.write("\2\2\b=\3\2\2\2\nJ\3\2\2\2\fO\3\2\2\2\16d\3\2\2\2\20i")
        buf.write("\3\2\2\2\22y\3\2\2\2\24~\3\2\2\2\26\u0082\3\2\2\2\30\u009d")
        buf.write("\3\2\2\2\32\u00c9\3\2\2\2\34\u00cb\3\2\2\2\36\u00d0\3")
        buf.write("\2\2\2 \u00d2\3\2\2\2\"\u00d7\3\2\2\2$\u00fa\3\2\2\2&")
        buf.write("\u0121\3\2\2\2(\u0124\3\2\2\2*\u0126\3\2\2\2,\60\5\4\3")
        buf.write("\2-/\5\f\7\2.-\3\2\2\2/\62\3\2\2\2\60.\3\2\2\2\60\61\3")
        buf.write("\2\2\2\61\63\3\2\2\2\62\60\3\2\2\2\63\64\7\2\2\3\64\3")
        buf.write("\3\2\2\2\65\66\7\5\2\2\66\67\5\6\4\2\67\5\3\2\2\289\5")
        buf.write("*\26\29:\7\n\2\2:;\5\b\5\2;<\7\13\2\2<\7\3\2\2\2=>\b\5")
        buf.write("\1\2>?\7\6\2\2?@\7\7\2\2@A\7\b\2\2AB\7\t\2\2BC\7\f\2\2")
        buf.write("CD\7\34\2\2DE\7\16\2\2EF\7\17\2\2FG\5*\26\2GH\7\r\2\2")
        buf.write("HI\5\n\6\2I\t\3\2\2\2JK\7\n\2\2KL\5\32\16\2LM\7\13\2\2")
        buf.write("MN\b\6\1\2N\13\3\2\2\2OP\7\5\2\2PS\5*\26\2QR\7!\2\2RT")
        buf.write("\5*\26\2SQ\3\2\2\2ST\3\2\2\2TU\3\2\2\2UY\7\n\2\2VX\5\16")
        buf.write("\b\2WV\3\2\2\2X[\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z_\3\2\2\2")
        buf.write("[Y\3\2\2\2\\^\5\20\t\2]\\\3\2\2\2^a\3\2\2\2_]\3\2\2\2")
        buf.write("_`\3\2\2\2`b\3\2\2\2a_\3\2\2\2bc\7\13\2\2c\r\3\2\2\2d")
        buf.write("e\5\30\r\2ef\5*\26\2fg\7\23\2\2gh\b\b\1\2h\17\3\2\2\2")
        buf.write("ij\b\t\1\2jk\5\22\n\2kt\7\f\2\2lq\5\24\13\2mn\7\26\2\2")
        buf.write("np\5\24\13\2om\3\2\2\2ps\3\2\2\2qo\3\2\2\2qr\3\2\2\2r")
        buf.write("u\3\2\2\2sq\3\2\2\2tl\3\2\2\2tu\3\2\2\2uv\3\2\2\2vw\7")
        buf.write("\r\2\2wx\5\26\f\2x\21\3\2\2\2yz\7\6\2\2z{\5\30\r\2{|\5")
        buf.write("*\26\2|}\b\n\1\2}\23\3\2\2\2~\177\5\30\r\2\177\u0080\5")
        buf.write("*\26\2\u0080\u0081\b\13\1\2\u0081\25\3\2\2\2\u0082\u0086")
        buf.write("\7\n\2\2\u0083\u0085\5\16\b\2\u0084\u0083\3\2\2\2\u0085")
        buf.write("\u0088\3\2\2\2\u0086\u0084\3\2\2\2\u0086\u0087\3\2\2\2")
        buf.write("\u0087\u008c\3\2\2\2\u0088\u0086\3\2\2\2\u0089\u008b\5")
        buf.write("\32\16\2\u008a\u0089\3\2\2\2\u008b\u008e\3\2\2\2\u008c")
        buf.write("\u008a\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u008f\3\2\2\2")
        buf.write("\u008e\u008c\3\2\2\2\u008f\u0090\7\"\2\2\u0090\u0091\5")
        buf.write("$\23\2\u0091\u0092\7\23\2\2\u0092\u0093\7\13\2\2\u0093")
        buf.write("\u0094\b\f\1\2\u0094\27\3\2\2\2\u0095\u0096\7\33\2\2\u0096")
        buf.write("\u0097\7\16\2\2\u0097\u009e\7\17\2\2\u0098\u0099\7\35")
        buf.write("\2\2\u0099\u009e\b\r\1\2\u009a\u009b\7\33\2\2\u009b\u009e")
        buf.write("\b\r\1\2\u009c\u009e\5*\26\2\u009d\u0095\3\2\2\2\u009d")
        buf.write("\u0098\3\2\2\2\u009d\u009a\3\2\2\2\u009d\u009c\3\2\2\2")
        buf.write("\u009e\31\3\2\2\2\u009f\u00a3\7\n\2\2\u00a0\u00a2\5\32")
        buf.write("\16\2\u00a1\u00a0\3\2\2\2\u00a2\u00a5\3\2\2\2\u00a3\u00a1")
        buf.write("\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6\3\2\2\2\u00a5")
        buf.write("\u00a3\3\2\2\2\u00a6\u00ca\7\13\2\2\u00a7\u00a8\7\20\2")
        buf.write("\2\u00a8\u00a9\5 \21\2\u00a9\u00aa\5\32\16\2\u00aa\u00ab")
        buf.write("\7\21\2\2\u00ab\u00ac\5\"\22\2\u00ac\u00ad\b\16\1\2\u00ad")
        buf.write("\u00ca\3\2\2\2\u00ae\u00af\7\22\2\2\u00af\u00b0\5\34\17")
        buf.write("\2\u00b0\u00b1\5\36\20\2\u00b1\u00b2\b\16\1\2\u00b2\u00ca")
        buf.write("\3\2\2\2\u00b3\u00b4\7\3\2\2\u00b4\u00b5\7\f\2\2\u00b5")
        buf.write("\u00b6\5$\23\2\u00b6\u00b7\7\r\2\2\u00b7\u00b8\7\23\2")
        buf.write("\2\u00b8\u00b9\b\16\1\2\u00b9\u00ca\3\2\2\2\u00ba\u00bb")
        buf.write("\5*\26\2\u00bb\u00bc\7\24\2\2\u00bc\u00bd\5$\23\2\u00bd")
        buf.write("\u00be\7\23\2\2\u00be\u00bf\b\16\1\2\u00bf\u00ca\3\2\2")
        buf.write("\2\u00c0\u00c1\5*\26\2\u00c1\u00c2\7\16\2\2\u00c2\u00c3")
        buf.write("\5$\23\2\u00c3\u00c4\7\17\2\2\u00c4\u00c5\7\24\2\2\u00c5")
        buf.write("\u00c6\5$\23\2\u00c6\u00c7\7\23\2\2\u00c7\u00c8\b\16\1")
        buf.write("\2\u00c8\u00ca\3\2\2\2\u00c9\u009f\3\2\2\2\u00c9\u00a7")
        buf.write("\3\2\2\2\u00c9\u00ae\3\2\2\2\u00c9\u00b3\3\2\2\2\u00c9")
        buf.write("\u00ba\3\2\2\2\u00c9\u00c0\3\2\2\2\u00ca\33\3\2\2\2\u00cb")
        buf.write("\u00cc\7\f\2\2\u00cc\u00cd\5$\23\2\u00cd\u00ce\7\r\2\2")
        buf.write("\u00ce\u00cf\b\17\1\2\u00cf\35\3\2\2\2\u00d0\u00d1\5\32")
        buf.write("\16\2\u00d1\37\3\2\2\2\u00d2\u00d3\7\f\2\2\u00d3\u00d4")
        buf.write("\5$\23\2\u00d4\u00d5\7\r\2\2\u00d5\u00d6\b\21\1\2\u00d6")
        buf.write("!\3\2\2\2\u00d7\u00d8\5\32\16\2\u00d8\u00d9\b\22\1\2\u00d9")
        buf.write("#\3\2\2\2\u00da\u00db\b\23\1\2\u00db\u00dc\7 \2\2\u00dc")
        buf.write("\u00fb\b\23\1\2\u00dd\u00de\7\27\2\2\u00de\u00fb\b\23")
        buf.write("\1\2\u00df\u00e0\7\30\2\2\u00e0\u00fb\b\23\1\2\u00e1\u00e2")
        buf.write("\5*\26\2\u00e2\u00e3\b\23\1\2\u00e3\u00fb\3\2\2\2\u00e4")
        buf.write("\u00fb\7\31\2\2\u00e5\u00e6\7\32\2\2\u00e6\u00e7\7\33")
        buf.write("\2\2\u00e7\u00e8\7\16\2\2\u00e8\u00e9\5$\23\2\u00e9\u00ea")
        buf.write("\7\17\2\2\u00ea\u00eb\b\23\1\2\u00eb\u00fb\3\2\2\2\u00ec")
        buf.write("\u00ed\7\32\2\2\u00ed\u00ee\5*\26\2\u00ee\u00ef\7\f\2")
        buf.write("\2\u00ef\u00f0\7\r\2\2\u00f0\u00fb\3\2\2\2\u00f1\u00f2")
        buf.write("\7\36\2\2\u00f2\u00f3\5$\23\4\u00f3\u00f4\b\23\1\2\u00f4")
        buf.write("\u00fb\3\2\2\2\u00f5\u00f6\7\f\2\2\u00f6\u00f7\5$\23\2")
        buf.write("\u00f7\u00f8\7\r\2\2\u00f8\u00f9\b\23\1\2\u00f9\u00fb")
        buf.write("\3\2\2\2\u00fa\u00da\3\2\2\2\u00fa\u00dd\3\2\2\2\u00fa")
        buf.write("\u00df\3\2\2\2\u00fa\u00e1\3\2\2\2\u00fa\u00e4\3\2\2\2")
        buf.write("\u00fa\u00e5\3\2\2\2\u00fa\u00ec\3\2\2\2\u00fa\u00f1\3")
        buf.write("\2\2\2\u00fa\u00f5\3\2\2\2\u00fb\u011e\3\2\2\2\u00fc\u00fd")
        buf.write("\f\17\2\2\u00fd\u00fe\5(\25\2\u00fe\u00ff\5$\23\20\u00ff")
        buf.write("\u0100\b\23\1\2\u0100\u011d\3\2\2\2\u0101\u0102\f\16\2")
        buf.write("\2\u0102\u0103\7\16\2\2\u0103\u0104\5$\23\2\u0104\u0105")
        buf.write("\7\17\2\2\u0105\u0106\b\23\1\2\u0106\u011d\3\2\2\2\u0107")
        buf.write("\u0108\f\r\2\2\u0108\u0109\7\25\2\2\u0109\u010a\7\4\2")
        buf.write("\2\u010a\u011d\b\23\1\2\u010b\u010c\f\f\2\2\u010c\u010d")
        buf.write("\7\25\2\2\u010d\u010e\5*\26\2\u010e\u0117\7\f\2\2\u010f")
        buf.write("\u0114\5&\24\2\u0110\u0111\7\26\2\2\u0111\u0113\5&\24")
        buf.write("\2\u0112\u0110\3\2\2\2\u0113\u0116\3\2\2\2\u0114\u0112")
        buf.write("\3\2\2\2\u0114\u0115\3\2\2\2\u0115\u0118\3\2\2\2\u0116")
        buf.write("\u0114\3\2\2\2\u0117\u010f\3\2\2\2\u0117\u0118\3\2\2\2")
        buf.write("\u0118\u0119\3\2\2\2\u0119\u011a\7\r\2\2\u011a\u011b\b")
        buf.write("\23\1\2\u011b\u011d\3\2\2\2\u011c\u00fc\3\2\2\2\u011c")
        buf.write("\u0101\3\2\2\2\u011c\u0107\3\2\2\2\u011c\u010b\3\2\2\2")
        buf.write("\u011d\u0120\3\2\2\2\u011e\u011c\3\2\2\2\u011e\u011f\3")
        buf.write("\2\2\2\u011f%\3\2\2\2\u0120\u011e\3\2\2\2\u0121\u0122")
        buf.write("\5$\23\2\u0122\u0123\b\24\1\2\u0123\'\3\2\2\2\u0124\u0125")
        buf.write("\7\37\2\2\u0125)\3\2\2\2\u0126\u0127\7#\2\2\u0127+\3\2")
        buf.write("\2\2\22\60SY_qt\u0086\u008c\u009d\u00a3\u00c9\u00fa\u0114")
        buf.write("\u0117\u011c\u011e")
        return buf.getvalue()


class threeParser ( Parser ):

    grammarFileName = "three.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'System.out.println'", "'length'", "'class'", 
                     "'public'", "'static'", "'void'", "'main'", "'{'", 
                     "'}'", "'('", "')'", "'['", "']'", "'if'", "'else'", 
                     "'while'", "';'", "'='", "'.'", "','", "'true'", "'false'", 
                     "'this'", "'new'", "'int'", "'String'", "'bool'", "'!'", 
                     "<INVALID>", "<INVALID>", "'extends'", "'return'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "Class", "Public", 
            "Static", "Void", "Main", "LBrace", "RBrace", "LPran", 
            "RPran", "LBrack", "RBrack", "If", "Else", "While", 
            "SemiColon", "Equals", "Dot", "Comma", "TRUE", "FALSE", 
            "This", "New", "IntType", "StringType", "BoolType", 
            "Exclamation", "BinaryOperator", "Integer", "Extends", 
            "Return", "Identifier", "WS", "COMMENT", "LINE_COMMENT" ]

    RULE_program = 0
    RULE_mainClass = 1
    RULE_mainClassDecl = 2
    RULE_mainMethodDecl = 3
    RULE_mainMethodBody = 4
    RULE_classDecl = 5
    RULE_varDecl = 6
    RULE_methodDecl = 7
    RULE_methodDeclName = 8
    RULE_methodParam = 9
    RULE_methodBody = 10
    RULE_type = 11
    RULE_statement = 12
    RULE_whileCondition = 13
    RULE_whileSt = 14
    RULE_ifCondition = 15
    RULE_elseSt = 16
    RULE_exp = 17
    RULE_methodInvocParams = 18
    RULE_binOp = 19
    RULE_identifier = 20

    ruleNames =  [ "program", "mainClass", "mainClassDecl", "mainMethodDecl", 
                   "mainMethodBody", "classDecl", "varDecl", "methodDecl", 
                   "methodDeclName", "methodParam", "methodBody", "type", 
                   "statement", "whileCondition", "whileSt", "ifCondition", 
                   "elseSt", "exp", "methodInvocParams", "binOp", "identifier" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    Class=3
    Public=4
    Static=5
    Void=6
    Main=7
    LBrace=8
    RBrace=9
    LPran=10
    RPran=11
    LBrack=12
    RBrack=13
    If=14
    Else=15
    While=16
    SemiColon=17
    Equals=18
    Dot=19
    Comma=20
    TRUE=21
    FALSE=22
    This=23
    New=24
    IntType=25
    StringType=26
    BoolType=27
    Exclamation=28
    BinaryOperator=29
    Integer=30
    Extends=31
    Return=32
    Identifier=33
    WS=34
    COMMENT=35
    LINE_COMMENT=36

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    from io import StringIO
    import operator
    ops = {
        '+' : operator.add,
        '-' : operator.sub,
        '*' : operator.mul,
        '/' : operator.truediv,
        '&&': operator.and_,
        '<' : operator.lt,
        '>' : operator.gt
    }

    conversion = {
        'float': float,
        'int': int,
    }

    temp_counter = label_counter = 0
    declare_dict = {}
    function_stack_size = 0
    param_count = 0
    method_text = None

    def create_method_text(self):
        if self.method_text is not None:
            self.method_text.close()

        self.method_text = StringIO()

    def create_temp(self):
        self.function_stack_size += 4
        self.temp_counter += 1
        return f"T{self.temp_counter}"

    def get_temp(self):
        return f"T{self.temp_counter}"

    def create_label(self):
        self.label_counter += 1
        return f"L{self.label_counter}"

    def get_label(self):
        return f"L{self.label_counter}"

    def is_temp(self, tmp: str):
        return tmp[0] == 'T'

    def remove_temp(self):
        self.temp_counter -= 1

    def declare(self, type, name):
        if name in self.declare_dict:
            self.declare_dict[name] = type
            return
        self.declare_dict[name] = type

    def clear_declare_dict(self):
        self.declare_dict.clear()

    def get_type(self, name):
        if name in self.declare_dict:
            return self.declare_dict[name]
        return None



    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mainClass(self):
            return self.getTypedRuleContext(threeParser.MainClassContext,0)


        def EOF(self):
            return self.getToken(threeParser.EOF, 0)

        def classDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.ClassDeclContext)
            else:
                return self.getTypedRuleContext(threeParser.ClassDeclContext,i)


        def getRuleIndex(self):
            return threeParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = threeParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 42
            self.mainClass()
            self.state = 46
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==threeParser.Class:
                self.state = 43
                self.classDecl()
                self.state = 48
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 49
            self.match(threeParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MainClassContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Class(self):
            return self.getToken(threeParser.Class, 0)

        def mainClassDecl(self):
            return self.getTypedRuleContext(threeParser.MainClassDeclContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_mainClass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMainClass" ):
                listener.enterMainClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMainClass" ):
                listener.exitMainClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMainClass" ):
                return visitor.visitMainClass(self)
            else:
                return visitor.visitChildren(self)




    def mainClass(self):

        localctx = threeParser.MainClassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_mainClass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(threeParser.Class)
            self.state = 52
            self.mainClassDecl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MainClassDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def LBrace(self):
            return self.getToken(threeParser.LBrace, 0)

        def mainMethodDecl(self):
            return self.getTypedRuleContext(threeParser.MainMethodDeclContext,0)


        def RBrace(self):
            return self.getToken(threeParser.RBrace, 0)

        def getRuleIndex(self):
            return threeParser.RULE_mainClassDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMainClassDecl" ):
                listener.enterMainClassDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMainClassDecl" ):
                listener.exitMainClassDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMainClassDecl" ):
                return visitor.visitMainClassDecl(self)
            else:
                return visitor.visitChildren(self)




    def mainClassDecl(self):

        localctx = threeParser.MainClassDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_mainClassDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.identifier()
            self.state = 55
            self.match(threeParser.LBrace)
            self.state = 56
            self.mainMethodDecl()
            self.state = 57
            self.match(threeParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MainMethodDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Public(self):
            return self.getToken(threeParser.Public, 0)

        def Static(self):
            return self.getToken(threeParser.Static, 0)

        def Void(self):
            return self.getToken(threeParser.Void, 0)

        def Main(self):
            return self.getToken(threeParser.Main, 0)

        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def StringType(self):
            return self.getToken(threeParser.StringType, 0)

        def LBrack(self):
            return self.getToken(threeParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(threeParser.RBrack, 0)

        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def mainMethodBody(self):
            return self.getTypedRuleContext(threeParser.MainMethodBodyContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_mainMethodDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMainMethodDecl" ):
                listener.enterMainMethodDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMainMethodDecl" ):
                listener.exitMainMethodDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMainMethodDecl" ):
                return visitor.visitMainMethodDecl(self)
            else:
                return visitor.visitChildren(self)




    def mainMethodDecl(self):

        localctx = threeParser.MainMethodDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_mainMethodDecl)
        try:
            self.enterOuterAlt(localctx, 1)

            print("main:")
            self.create_method_text()
            self.function_stack_size = 0

            self.state = 60
            self.match(threeParser.Public)
            self.state = 61
            self.match(threeParser.Static)
            self.state = 62
            self.match(threeParser.Void)
            self.state = 63
            self.match(threeParser.Main)
            self.state = 64
            self.match(threeParser.LPran)
            self.state = 65
            self.match(threeParser.StringType)
            self.state = 66
            self.match(threeParser.LBrack)
            self.state = 67
            self.match(threeParser.RBrack)
            self.state = 68
            self.identifier()
            self.state = 69
            self.match(threeParser.RPran)
            self.state = 70
            self.mainMethodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MainMethodBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.st = None # StatementContext

        def LBrace(self):
            return self.getToken(threeParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(threeParser.RBrace, 0)

        def statement(self):
            return self.getTypedRuleContext(threeParser.StatementContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_mainMethodBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMainMethodBody" ):
                listener.enterMainMethodBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMainMethodBody" ):
                listener.exitMainMethodBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMainMethodBody" ):
                return visitor.visitMainMethodBody(self)
            else:
                return visitor.visitChildren(self)




    def mainMethodBody(self):

        localctx = threeParser.MainMethodBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_mainMethodBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(threeParser.LBrace)
            self.state = 73
            localctx.st = self.statement()
            self.state = 74
            self.match(threeParser.RBrace)

            print(f"\tbeginFunc {self.function_stack_size}\n{self.method_text.getvalue()}\tret")

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Class(self):
            return self.getToken(threeParser.Class, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(threeParser.IdentifierContext,i)


        def LBrace(self):
            return self.getToken(threeParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(threeParser.RBrace, 0)

        def Extends(self):
            return self.getToken(threeParser.Extends, 0)

        def varDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.VarDeclContext)
            else:
                return self.getTypedRuleContext(threeParser.VarDeclContext,i)


        def methodDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.MethodDeclContext)
            else:
                return self.getTypedRuleContext(threeParser.MethodDeclContext,i)


        def getRuleIndex(self):
            return threeParser.RULE_classDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDecl" ):
                listener.enterClassDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDecl" ):
                listener.exitClassDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassDecl" ):
                return visitor.visitClassDecl(self)
            else:
                return visitor.visitChildren(self)




    def classDecl(self):

        localctx = threeParser.ClassDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_classDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(threeParser.Class)
            self.state = 78
            self.identifier()
            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==threeParser.Extends:
                self.state = 79
                self.match(threeParser.Extends)
                self.state = 80
                self.identifier()


            self.state = 83
            self.match(threeParser.LBrace)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << threeParser.IntType) | (1 << threeParser.BoolType) | (1 << threeParser.Identifier))) != 0):
                self.state = 84
                self.varDecl()
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 93
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==threeParser.Public:
                self.state = 90
                self.methodDecl()
                self.state = 95
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 96
            self.match(threeParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None # TypeContext
            self.id = None # IdentifierContext

        def SemiColon(self):
            return self.getToken(threeParser.SemiColon, 0)

        def type(self):
            return self.getTypedRuleContext(threeParser.TypeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_varDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDecl" ):
                listener.enterVarDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDecl" ):
                listener.exitVarDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDecl" ):
                return visitor.visitVarDecl(self)
            else:
                return visitor.visitChildren(self)




    def varDecl(self):

        localctx = threeParser.VarDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_varDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            localctx.t = self.type()
            self.state = 99
            localctx.id = self.identifier()
            self.state = 100
            self.match(threeParser.SemiColon)

            self.declare((None if localctx.t is None else self._input.getText(localctx.t.start,localctx.t.stop)), (None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop)))
            self.function_stack_size += 4

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodDeclName(self):
            return self.getTypedRuleContext(threeParser.MethodDeclNameContext,0)


        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def methodBody(self):
            return self.getTypedRuleContext(threeParser.MethodBodyContext,0)


        def methodParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.MethodParamContext)
            else:
                return self.getTypedRuleContext(threeParser.MethodParamContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(threeParser.Comma)
            else:
                return self.getToken(threeParser.Comma, i)

        def getRuleIndex(self):
            return threeParser.RULE_methodDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDecl" ):
                listener.enterMethodDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDecl" ):
                listener.exitMethodDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodDecl" ):
                return visitor.visitMethodDecl(self)
            else:
                return visitor.visitChildren(self)




    def methodDecl(self):

        localctx = threeParser.MethodDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_methodDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)

            self.create_method_text()
            self.function_stack_size = 0

            self.state = 104
            self.methodDeclName()
            self.state = 105
            self.match(threeParser.LPran)
            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << threeParser.IntType) | (1 << threeParser.BoolType) | (1 << threeParser.Identifier))) != 0):
                self.state = 106
                self.methodParam()
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==threeParser.Comma:
                    self.state = 107
                    self.match(threeParser.Comma)
                    self.state = 108
                    self.methodParam()
                    self.state = 113
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 116
            self.match(threeParser.RPran)
            self.state = 117
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDeclNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.id = None # IdentifierContext

        def Public(self):
            return self.getToken(threeParser.Public, 0)

        def type(self):
            return self.getTypedRuleContext(threeParser.TypeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_methodDeclName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDeclName" ):
                listener.enterMethodDeclName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDeclName" ):
                listener.exitMethodDeclName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodDeclName" ):
                return visitor.visitMethodDeclName(self)
            else:
                return visitor.visitChildren(self)




    def methodDeclName(self):

        localctx = threeParser.MethodDeclNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_methodDeclName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(threeParser.Public)
            self.state = 120
            self.type()
            self.state = 121
            localctx.id = self.identifier()

            print(f"{(None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))}:")

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None # TypeContext
            self.id = None # IdentifierContext

        def type(self):
            return self.getTypedRuleContext(threeParser.TypeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_methodParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodParam" ):
                listener.enterMethodParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodParam" ):
                listener.exitMethodParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodParam" ):
                return visitor.visitMethodParam(self)
            else:
                return visitor.visitChildren(self)




    def methodParam(self):

        localctx = threeParser.MethodParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_methodParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            localctx.t = self.type()
            self.state = 125
            localctx.id = self.identifier()

            self.declare((None if localctx.t is None else self._input.getText(localctx.t.start,localctx.t.stop)), (None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop)))

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._exp = None # ExpContext

        def LBrace(self):
            return self.getToken(threeParser.LBrace, 0)

        def Return(self):
            return self.getToken(threeParser.Return, 0)

        def exp(self):
            return self.getTypedRuleContext(threeParser.ExpContext,0)


        def SemiColon(self):
            return self.getToken(threeParser.SemiColon, 0)

        def RBrace(self):
            return self.getToken(threeParser.RBrace, 0)

        def varDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.VarDeclContext)
            else:
                return self.getTypedRuleContext(threeParser.VarDeclContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.StatementContext)
            else:
                return self.getTypedRuleContext(threeParser.StatementContext,i)


        def getRuleIndex(self):
            return threeParser.RULE_methodBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodBody" ):
                listener.enterMethodBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodBody" ):
                listener.exitMethodBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodBody" ):
                return visitor.visitMethodBody(self)
            else:
                return visitor.visitChildren(self)




    def methodBody(self):

        localctx = threeParser.MethodBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_methodBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(threeParser.LBrace)
            self.state = 132
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 129
                    self.varDecl() 
                self.state = 134
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << threeParser.T__0) | (1 << threeParser.LBrace) | (1 << threeParser.If) | (1 << threeParser.While) | (1 << threeParser.Identifier))) != 0):
                self.state = 135
                self.statement()
                self.state = 140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 141
            self.match(threeParser.Return)
            self.state = 142
            localctx._exp = self.exp(0)
            self.state = 143
            self.match(threeParser.SemiColon)
            self.state = 144
            self.match(threeParser.RBrace)

            print(f"\tbeginFunc {self.function_stack_size}\n{self.method_text.getvalue()}\tret {localctx._exp.value_attr}")

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.size_attr = int()
            self.id = None # IdentifierContext

        def IntType(self):
            return self.getToken(threeParser.IntType, 0)

        def LBrack(self):
            return self.getToken(threeParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(threeParser.RBrack, 0)

        def BoolType(self):
            return self.getToken(threeParser.BoolType, 0)

        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)




    def type(self):

        localctx = threeParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_type)
        try:
            self.state = 155
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 147
                self.match(threeParser.IntType)
                self.state = 148
                self.match(threeParser.LBrack)
                self.state = 149
                self.match(threeParser.RBrack)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 150
                self.match(threeParser.BoolType)

                localctx.size_attr = 1

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 152
                self.match(threeParser.IntType)

                localctx.size_attr = 4

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 154
                localctx.id = self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value_attr = str()
            self.type_attr = str()
            self.is_var = bool()
            self.st1 = None # StatementContext
            self.c = None # WhileConditionContext
            self._exp = None # ExpContext
            self.id = None # IdentifierContext
            self.e = None # ExpContext
            self.e2 = None # ExpContext

        def LBrace(self):
            return self.getToken(threeParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(threeParser.RBrace, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.StatementContext)
            else:
                return self.getTypedRuleContext(threeParser.StatementContext,i)


        def If(self):
            return self.getToken(threeParser.If, 0)

        def ifCondition(self):
            return self.getTypedRuleContext(threeParser.IfConditionContext,0)


        def Else(self):
            return self.getToken(threeParser.Else, 0)

        def elseSt(self):
            return self.getTypedRuleContext(threeParser.ElseStContext,0)


        def While(self):
            return self.getToken(threeParser.While, 0)

        def whileSt(self):
            return self.getTypedRuleContext(threeParser.WhileStContext,0)


        def whileCondition(self):
            return self.getTypedRuleContext(threeParser.WhileConditionContext,0)


        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.ExpContext)
            else:
                return self.getTypedRuleContext(threeParser.ExpContext,i)


        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def SemiColon(self):
            return self.getToken(threeParser.SemiColon, 0)

        def Equals(self):
            return self.getToken(threeParser.Equals, 0)

        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def LBrack(self):
            return self.getToken(threeParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(threeParser.RBrack, 0)

        def getRuleIndex(self):
            return threeParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = threeParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 199
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 157
                self.match(threeParser.LBrace)
                self.state = 161
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << threeParser.T__0) | (1 << threeParser.LBrace) | (1 << threeParser.If) | (1 << threeParser.While) | (1 << threeParser.Identifier))) != 0):
                    self.state = 158
                    self.statement()
                    self.state = 163
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 164
                self.match(threeParser.RBrace)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 165
                self.match(threeParser.If)
                self.state = 166
                self.ifCondition()
                self.state = 167
                localctx.st1 = self.statement()
                self.state = 168
                self.match(threeParser.Else)
                self.state = 169
                self.elseSt()

                if_label = self.get_label()
                end = self.create_label()
                print(f"\tgoto {end}", file=self.method_text)
                print(f"{if_label}:", file=self.method_text)
                print(f"\t{localctx.st1.value_attr}", file=self.method_text)
                print(f"{end}:", file=self.method_text)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 172
                self.match(threeParser.While)
                self.state = 173
                localctx.c = self.whileCondition()
                self.state = 174
                self.whileSt()

                before = localctx.c.before
                after = localctx.c.after
                print(f"\tgoto {before}", file=self.method_text)
                print(f"\tgoto {after}", file=self.method_text)
                print(f"{after}:", file=self.method_text)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 177
                self.match(threeParser.T__0)
                self.state = 178
                self.match(threeParser.LPran)
                self.state = 179
                localctx._exp = self.exp(0)
                self.state = 180
                self.match(threeParser.RPran)
                self.state = 181
                self.match(threeParser.SemiColon)

                print(f"\tpush {localctx._exp.value_attr}", file=self.method_text)
                print("\tcall System.out.println", file=self.method_text)
                print(f"\tpopParams {4}", file=self.method_text)
                self.param_count = 0;

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 184
                localctx.id = self.identifier()
                self.state = 185
                self.match(threeParser.Equals)
                self.state = 186
                localctx.e = self.exp(0)
                self.state = 187
                self.match(threeParser.SemiColon)

                t = self.create_temp()
                if localctx.e.type_attr == "str":
                    localctx.value_attr = f"{t} = {localctx.e.value_attr}\n\t{(None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))} = {t}"
                else:
                   localctx.value_attr = f"{(None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))} = {localctx.e.value_attr}"
                print(f"\t{localctx.value_attr}", file=self.method_text)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 190
                localctx.id = self.identifier()
                self.state = 191
                self.match(threeParser.LBrack)
                self.state = 192
                localctx.e = self.exp(0)
                self.state = 193
                self.match(threeParser.RBrack)
                self.state = 194
                self.match(threeParser.Equals)
                self.state = 195
                localctx.e2 = self.exp(0)
                self.state = 196
                self.match(threeParser.SemiColon)

                t = self.create_temp()
                addr = self.create_temp()
                print(f"\t{t} = {localctx.e.value_attr} * 4", file=self.method_text)
                print(f"\t{addr} = {t} + {(None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))}", file=self.method_text)
                if not self.is_temp(localctx.e2.value_attr):
                    value = self.create_temp()
                    print(f"\t{value} = {localctx.e2.value_attr}", file=self.method_text)
                    print(f"\t*({addr}) = {value}", file=self.method_text)
                else:
                    print(f"\t*({addr}) = {localctx.e2.value_attr}", file=self.method_text)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.before = str()
            self.after = str()
            self.e = None # ExpContext

        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def exp(self):
            return self.getTypedRuleContext(threeParser.ExpContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_whileCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileCondition" ):
                listener.enterWhileCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileCondition" ):
                listener.exitWhileCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileCondition" ):
                return visitor.visitWhileCondition(self)
            else:
                return visitor.visitChildren(self)




    def whileCondition(self):

        localctx = threeParser.WhileConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_whileCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(threeParser.LPran)
            self.state = 202
            localctx.e = self.exp(0)
            self.state = 203
            self.match(threeParser.RPran)

            localctx.before = self.create_label()
            localctx.after = self.create_label()
            t = self.create_temp()
            print(f"{localctx.before}:", file=self.method_text)
            print(f"\t{t} = {localctx.e.value_attr}", file=self.method_text)
            print(f"\tifz {t} goto {localctx.after}", file=self.method_text)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.st = None # StatementContext

        def statement(self):
            return self.getTypedRuleContext(threeParser.StatementContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_whileSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileSt" ):
                listener.enterWhileSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileSt" ):
                listener.exitWhileSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileSt" ):
                return visitor.visitWhileSt(self)
            else:
                return visitor.visitChildren(self)




    def whileSt(self):

        localctx = threeParser.WhileStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_whileSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            localctx.st = self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e = None # ExpContext

        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def exp(self):
            return self.getTypedRuleContext(threeParser.ExpContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_ifCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfCondition" ):
                listener.enterIfCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfCondition" ):
                listener.exitIfCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfCondition" ):
                return visitor.visitIfCondition(self)
            else:
                return visitor.visitChildren(self)




    def ifCondition(self):

        localctx = threeParser.IfConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_ifCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(threeParser.LPran)
            self.state = 209
            localctx.e = self.exp(0)
            self.state = 210
            self.match(threeParser.RPran)

            if_label = self.create_label()
            t = self.create_temp()
            print(f"\t{t} = {localctx.e.value_attr}", file=self.method_text)
            print(f"\tifz {t} goto {if_label}", file=self.method_text)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseStContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.st = None # StatementContext

        def statement(self):
            return self.getTypedRuleContext(threeParser.StatementContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_elseSt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseSt" ):
                listener.enterElseSt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseSt" ):
                listener.exitElseSt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseSt" ):
                return visitor.visitElseSt(self)
            else:
                return visitor.visitChildren(self)




    def elseSt(self):

        localctx = threeParser.ElseStContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_elseSt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            localctx.st = self.statement()

            print(f"\t{localctx.st.value_attr}", file=self.method_text)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value_attr = str()
            self.type_attr = str()
            self.is_var = bool()
            self.is_complete = bool()
            self.e1 = None # ExpContext
            self._Integer = None # Token
            self._TRUE = None # Token
            self._FALSE = None # Token
            self.id = None # IdentifierContext
            self._exp = None # ExpContext
            self.op = None # BinOpContext
            self.e2 = None # ExpContext

        def Integer(self):
            return self.getToken(threeParser.Integer, 0)

        def TRUE(self):
            return self.getToken(threeParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(threeParser.FALSE, 0)

        def identifier(self):
            return self.getTypedRuleContext(threeParser.IdentifierContext,0)


        def This(self):
            return self.getToken(threeParser.This, 0)

        def New(self):
            return self.getToken(threeParser.New, 0)

        def IntType(self):
            return self.getToken(threeParser.IntType, 0)

        def LBrack(self):
            return self.getToken(threeParser.LBrack, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.ExpContext)
            else:
                return self.getTypedRuleContext(threeParser.ExpContext,i)


        def RBrack(self):
            return self.getToken(threeParser.RBrack, 0)

        def LPran(self):
            return self.getToken(threeParser.LPran, 0)

        def RPran(self):
            return self.getToken(threeParser.RPran, 0)

        def Exclamation(self):
            return self.getToken(threeParser.Exclamation, 0)

        def binOp(self):
            return self.getTypedRuleContext(threeParser.BinOpContext,0)


        def Dot(self):
            return self.getToken(threeParser.Dot, 0)

        def methodInvocParams(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(threeParser.MethodInvocParamsContext)
            else:
                return self.getTypedRuleContext(threeParser.MethodInvocParamsContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(threeParser.Comma)
            else:
                return self.getToken(threeParser.Comma, i)

        def getRuleIndex(self):
            return threeParser.RULE_exp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExp" ):
                listener.enterExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExp" ):
                listener.exitExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExp" ):
                return visitor.visitExp(self)
            else:
                return visitor.visitChildren(self)



    def exp(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = threeParser.ExpContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_exp, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 217
                localctx._Integer = self.match(threeParser.Integer)

                localctx.value_attr=(None if localctx._Integer is None else localctx._Integer.text)
                localctx.type_attr="int"

                pass

            elif la_ == 2:
                self.state = 219
                localctx._TRUE = self.match(threeParser.TRUE)

                localctx.value_attr=(None if localctx._TRUE is None else localctx._TRUE.text)
                localctx.type_attr="boolean"

                pass

            elif la_ == 3:
                self.state = 221
                localctx._FALSE = self.match(threeParser.FALSE)

                localctx.value_attr=(None if localctx._FALSE is None else localctx._FALSE.text)
                localctx.type_attr="boolean"

                pass

            elif la_ == 4:
                self.state = 223
                localctx.id = self.identifier()

                name = (None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))
                type = self.get_type(name)
                if type is None:
                    print(f"this shouldn't happen: {name}")
                    return
                localctx.is_var = True
                localctx.value_attr= name
                localctx.type_attr= type

                pass

            elif la_ == 5:
                self.state = 226
                self.match(threeParser.This)
                pass

            elif la_ == 6:
                self.state = 227
                self.match(threeParser.New)
                self.state = 228
                self.match(threeParser.IntType)
                self.state = 229
                self.match(threeParser.LBrack)
                self.state = 230
                localctx._exp = self.exp(0)
                self.state = 231
                self.match(threeParser.RBrack)

                self.function_stack_size += 4

                pass

            elif la_ == 7:
                self.state = 234
                self.match(threeParser.New)
                self.state = 235
                self.identifier()
                self.state = 236
                self.match(threeParser.LPran)
                self.state = 237
                self.match(threeParser.RPran)
                pass

            elif la_ == 8:
                self.state = 239
                self.match(threeParser.Exclamation)
                self.state = 240
                localctx._exp = self.exp(2)

                t = self.create_temp()
                if localctx._exp.type_attr == "str":
                    print(f"\t{t} = {localctx._exp.value_attr}", file=self.method_text)
                    print(f"\t{t} = !{t}", file=self.method_text)
                else:
                    t = self.create_temp()
                    print(f"\t{t} = !{localctx._exp.value_attr}", file=self.method_text)
                localctx.value_attr = t
                localctx.type_attr = "int"

                pass

            elif la_ == 9:
                self.state = 243
                self.match(threeParser.LPran)
                self.state = 244
                localctx._exp = self.exp(0)
                self.state = 245
                self.match(threeParser.RPran)

                localctx.value_attr = localctx._exp.value_attr
                localctx.type_attr = localctx._exp.type_attr
                localctx.is_var = localctx._exp.is_var

                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 284
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 282
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                    if la_ == 1:
                        localctx = threeParser.ExpContext(self, _parentctx, _parentState)
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                        self.state = 250
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")

                        self.state = 251
                        localctx.op = self.binOp()
                        self.state = 252
                        localctx.e2 = localctx._exp = self.exp(14)

                        #if localctx.e1.type_attr != localctx.e2.type_attr:
                        #    print('Semantic error4 in "+" operator: Inconsistent types!', localctx.e1.type_attr, localctx.e1.value_attr ,localctx.e2.type_attr, localctx.e2.value_attr)
                        #else:
                        localctx.value_attr = f"{localctx.e1.value_attr} {(None if localctx.op is None else self._input.getText(localctx.op.start,localctx.op.stop))} {localctx.e2.value_attr}"
                        localctx.type_attr = "str"
                        localctx.is_complete = True
                        
                        pass

                    elif la_ == 2:
                        localctx = threeParser.ExpContext(self, _parentctx, _parentState)
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                        self.state = 255
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 256
                        self.match(threeParser.LBrack)
                        self.state = 257
                        localctx.e2 = localctx._exp = self.exp(0)
                        self.state = 258
                        self.match(threeParser.RBrack)

                        t = self.create_temp()
                        ptr = self.create_temp()
                        value = self.create_temp()
                        print(f"\t{t} = {localctx.e2.value_attr} * 4", file=self.method_text)
                        print(f"\t{ptr} = {localctx.e1.value_attr} + {t}", file=self.method_text)
                        print(f"\t{value} = *({ptr})", file=self.method_text)
                        localctx.value_attr = value
                        
                        pass

                    elif la_ == 3:
                        localctx = threeParser.ExpContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                        self.state = 261
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 262
                        self.match(threeParser.Dot)
                        self.state = 263
                        self.match(threeParser.T__1)

                        # print("hey there")
                        
                        pass

                    elif la_ == 4:
                        localctx = threeParser.ExpContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                        self.state = 265
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 266
                        self.match(threeParser.Dot)
                        self.state = 267
                        localctx.id = self.identifier()
                        self.state = 268
                        self.match(threeParser.LPran)
                        self.state = 277
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << threeParser.LPran) | (1 << threeParser.TRUE) | (1 << threeParser.FALSE) | (1 << threeParser.This) | (1 << threeParser.New) | (1 << threeParser.Exclamation) | (1 << threeParser.Integer) | (1 << threeParser.Identifier))) != 0):
                            self.state = 269
                            self.methodInvocParams()
                            self.state = 274
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            while _la==threeParser.Comma:
                                self.state = 270
                                self.match(threeParser.Comma)
                                self.state = 271
                                self.methodInvocParams()
                                self.state = 276
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)



                        self.state = 279
                        self.match(threeParser.RPran)

                        t = self.create_temp()
                        localctx.value_attr =  t
                        localctx.type_attr = "ret_var"
                        localctx.is_var = True
                        print(f"\t{t} = call {(None if localctx.id is None else self._input.getText(localctx.id.start,localctx.id.stop))}", file=self.method_text)
                        print(f"\tpopParams {self.param_count * 4}", file=self.method_text)
                        self.param_count = 0
                        
                        pass

             
                self.state = 286
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class MethodInvocParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e1 = None # ExpContext

        def exp(self):
            return self.getTypedRuleContext(threeParser.ExpContext,0)


        def getRuleIndex(self):
            return threeParser.RULE_methodInvocParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodInvocParams" ):
                listener.enterMethodInvocParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodInvocParams" ):
                listener.exitMethodInvocParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodInvocParams" ):
                return visitor.visitMethodInvocParams(self)
            else:
                return visitor.visitChildren(self)




    def methodInvocParams(self):

        localctx = threeParser.MethodInvocParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_methodInvocParams)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            localctx.e1 = self.exp(0)

            self.param_count += 1

            if localctx.e1.type_attr == "str":
                t = self.create_temp()
                print(f"\t{t} = {localctx.e1.value_attr}", file=self.method_text)
                print(f"\tpush {t}", file=self.method_text)
            else:
                print(f"\tpush {localctx.e1.value_attr}", file=self.method_text)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BinaryOperator(self):
            return self.getToken(threeParser.BinaryOperator, 0)

        def getRuleIndex(self):
            return threeParser.RULE_binOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinOp" ):
                listener.enterBinOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinOp" ):
                listener.exitBinOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinOp" ):
                return visitor.visitBinOp(self)
            else:
                return visitor.visitChildren(self)




    def binOp(self):

        localctx = threeParser.BinOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_binOp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(threeParser.BinaryOperator)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(threeParser.Identifier, 0)

        def getRuleIndex(self):
            return threeParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = threeParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(threeParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[17] = self.exp_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def exp_sempred(self, localctx:ExpContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 10)
         




